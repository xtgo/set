// Code generated by "mkgoset Strings string"; DO NOT EDIT.

package set

import "sort"

type Strings struct{ data sort.StringSlice }

func NewStrings(elems ...string) Strings {
	data := append(sort.StringSlice(nil), elems...)
	sort.Sort(data)
	size := setalgo.Uniq(data)
	return Strings{data[:size]}
}

func (s Strings) mutate(fn setalgo.Op, t Strings) Strings {
	data := append(s.data, t.data...)
	n := fn(data, len(s.data))
	return Strings{data[:n]}
}

func (s Strings) check(fn func(sort.Interface, int) bool, t Strings) bool {
	data := append(s.data, t.data...)
	return fn(data, len(s.data))
}

func (s Strings) Len() int                     { return len(s.data) }
func (s Strings) Append(dst []string) []string { return append(dst, s.data...) }
func (s Strings) Copy() Strings                { return Strings{s.Append(nil)} }

// TODO: add cap param to Copy, to make it handle Grow case too?

func (s Strings) Union(t Strings) Strings   { return s.mutate(setalgo.Union, t) }
func (s Strings) Inter(t Strings) Strings   { return s.mutate(setalgo.Inter, t) }
func (s Strings) SymDiff(t Strings) Strings { return s.mutate(setalgo.SymDiff, t) }
func (s Strings) Diff(t Strings) Strings    { return s.mutate(setalgo.Diff, t) }

func (s Strings) IsEqual(t Strings) bool { return s.check(setalgo.IsEqual, t) }
func (s Strings) IsInter(t Strings) bool { return s.check(setalgo.IsInter, t) }
func (s Strings) IsSub(t Strings) bool   { return s.check(setalgo.IsSub, t) }
func (s Strings) IsSuper(t Strings) bool { return s.check(setalgo.IsSub, t) }
